%% KINEMATICS AND ROBOTICS
%  INTRODUCTION TO CURVES AND SURFACES
 
%% The MATLAB user interface 
 
% Command Window 
% Workspace 
% Command History 
% Current Folder
% Editor

% At the beginning of your MATLAB session you have to choose your current
% folder; this is the directory where your files will be stored

%% ELEMENTARY COMPUTATIONS
%
% Write the following commands into your command window
% and execute them via "RETURN":

3+4
%
% COMMAND:

x = 3+4

% SUPRESS ECHO: If you do not want to see the result in the command window
% end the command with a semicolon ";" 

b = 3*4;

% Instead,the result is stored in the storage "b".
% If you want to see the content of b, type "b" in the command window:

b

% powers 
n = 2^25;

% some standard functions:
sin(pi/3)
cos(pi/2)
tan(pi/4)

% factorial:
f = factorial(4)

% binomial coefficients
y = nchoosek(4,2)


%% COMMENTS

% You can also mark text as comments by using the "%"-character:

% We now compute a big number: (this line is a comment)

bigNumber = factorial(100)


%% SOME HELPFUL FEATURES

% clearing all assignments:
clear all

% clearing the command window:
clc

% help on a MATLAB command:
help clc

% documentation on a MATLAB command:
doc clc

%% VECTORS AND MATRICES

clear all;
clc;

% column vectors:
a = [3;4;0]

% row vectors (two options, same result):
b = [1 2 3]
c = [5,2,1]

% matrices: 
A = [1 2 3; 4 5 6; 7 8 9]
B = [4 2 1; 3 7 0; 4 1 8]

%% STANDARD OPERATIONS WITH VECTORS AND MATRICES

b+c

% matrix multiplication:
a1 = A*a
D = A*B

% The following command produces an error because the matrix dimensions don not fit:
%b1 = A*b

% This one is correct:
b1 = b*A

% the norm of a vector:
na = norm(a)

% transposing a vector or a matrix:
bt = b'
At = A'

% a row vector that divides an interval into equal parts:
x = linspace(0, 10, 3)


%% ELEMENT-WISE OPERATIONS WITH MATRICES

% You can also apply element-wise operations to vectors and matrices.
% In this case you have to put a "." in front of 
% the respective operator ("*", "/", ...).
% Here are some examples:

b.*c
b./c
C = A.*B

% Standard functions operate element-wise per default:

S = sin(A)

% Try this one:

1 - x

% Here MATLAB is pretty tolerant in terms of data structure.
% In this case "1" is interpreted as a vector whose components are all 1.
% The vector has as many components as the vector x.
% This way the handling some commands is more comfortable.

%% ACCESSING A VECTOR ELEMENT, A MATRIX ELEMENT, A MATRIX COLUMN OR A MATRIX ROW 

a2 = a(2)
c(3)
A(2,1)
B(:,3)
D(1,:)

%% SCRIPTS AND m-FILES

% In order to record your activity for further use
%    you can write your commands in a script and save it as an "m-file".
% The text you are reading right now is part 
%    of the script "curvesAndSurfaces.m". 
% To generate a new script simply use "New/script" from the menu "File".
% To save the script under a new name use "Save As" from the menu "File".
% You can write commands and comments in your script 
%    in the same way as in the command window.
% Execute your commands in the script by "ctrl RETURN" 
%    or by using the respective buttons
% You can also execute the complete script by typing its name in the
%    command window (without the suffix ".m") and then using the "RETURN"-key.

%% THE CELL MODE

% In a script you can partition your input code into so-called "cells"
% A new cell is generated by a "%%" optionally followed 
%    by the headline of the respective cell.
% The file where you are reading these lines has also been 
%    divided into cells this way.
% A script-file can be executed cell by cell using "CTRL RETURN" 
%    or by using the respective button "RUN AND ADVANCE" in the command .

%% EXERCISE: Generate a new cell containing some comments and some commands

%% GRAPHICS PART 1: Plotting a function in one variable y = f(x):

clear all;
clc;

% Create a vector x containing the x-coordinates:
n = 60; 
x = linspace(0, 2*pi, n);


% Create a vector y containing the y-coordinates:

y = sin(x);

% Note that the function "sin" is applied element-wise to the vector x.

% The vectors x and y can be interpreted as the x- and y-coordinates of  
%    a polygon with n vertices. The polygon can be plotted via the command "plot":
 

fPlot = plot(x, y);

%% GRAPHICS PART 2: Modifying plot options (2D-case):

set(fPlot, 'Color', [0, 0, 1],... 
           'LineWidth', 2); 
axis equal
xlim([-.5, 2*pi+0.5])
ylim([-1.5, 1.5])

% Check which further modifications of the graphical output 
%    are possible right in the plot window! 

%% GRAPHICS PART 3: Plotting a planar parametric curve c = [x(t), y(t)]:

clear all;
clc;

% Create a vector t containing the t-values:
t = linspace(0, 2*pi, 60);

% Create a vector x containing the x-coordinates:
x = cos(t);

% Create a vector y containing the y-coordinates:
y = sin(t);

% Plot the polygon consisting of the points whose x-coordinates and 
%    y-coordinates are stored in the vectors x and y, respectively. 

c = plot(x, y);

% some plot options:

set(c, 'Color', [1, 0.5, 0],... 
       'LineWidth', 4);
axis equal
xlim([-1.5, 1.5])
ylim([-1.5, 1.5])

%% EXERCISE: Plot an ellipse as a parametric curve


%% EXERCISE: Plot a parabola as a parametric curve
% Parameterization of a parabola: c(t) = [(t^2)/(2*p), t]
%     where p is a constant number.

%% EXERCISE: Plot a straight line segment as a parametric curve
% The line segment shall connect the points P and Q in the xy-plane!

clear all;
clc;

% The points P and Q are given by their column vectors

P = [1; 1]
Q = [5; 10]

% create a vector t containing the t-values in [0,1]:
n = 6;
t = linspace(0, 1, n)

x = (1-t) * P(1) + t * Q(1)
y = (1-t) * P(2) + t * Q(2)

L = plot(x,y);

% SOME PLOT OPTIONS: 
axis equal
xlim([0, 6])
ylim([0, 11])

set(L, 'Color', [1, 0, 0],...
       'LineWidth', 4); 


%% GRAPHICS PART 4: PLOTTING A PARAMETRIC SPACE CURVE c = [x(t), y(t), z(t)]:

clear all;
clc;

% Create a vector t containing the t-values:
t = linspace(0, 6*pi, 100);

% Create a vector x containing the x-coordinates:
x = 3*sin(t);

% Create a vector y containing the y-coordinates:
y = 3*cos(t);

% Create a vector z containing the z-coordinates:
z = 0.5*t;

% Plot the polygon consisting of the points whose x-coordinates,  
% y-coordinates and z-coordinates are stored 
% in the vectors x, y and z, respectively (command: "plot3"):
c = plot3(x, y, z);
% Mind that, in 3-space, we have to use the command "plot3" instead of "plot"!

% some plot options:

set(c, 'Color', [1, 0, 0],...
       'LineWidth', 4); 
axis equal
xlim([-3, 3])
grid on

%% EXERCISE: Plot a straight line segment in space as a parametric curve
% the line segment must connect the given points p1=[1;2;3] and 
% p2=[4;3;1] in space!


%% GRAPHICS PART 5: Plotting a surface given by an explicit function in 2 variables z = f(x,y):

clear all;
clc;

% Create a vector x containing the x-values:
x = linspace(-2, 2, 5)

% Create a vector y containing the y-values:
y = linspace(-2, 2, 3)

% Create two matrices X and Y containing the coordinates of the x- and 
% y-values, respectively:
[X,Y] = meshgrid(x, y)

% Create a matrix Z containing the corresponding z-values:
Z = X.^2 - Y.^2;
% element-wise operation!! 

% Plot the mesh consisting of the points whose x-coordinates,  
% y-coordinates and z-coordinates are stored 
% in the matrices X, Y and Z, respectively (plot-command: "surf"):
s = surf(X,Y,Z);



%% EXERCISE: Plot the surface given by the function z = x*y


%% %% EXERCISE: Plot the surface given by the function z = 0.5*sin(x+y)


%% GRAPHICS PART 6: Plotting a parametric surface s = [x(u,v), y(u,v), z(u,v)]: 

clear all;
clc;

% Create vectors u and v containing the u- and v-values 
% of the parameter domain:
m = 60; 
n = 30; 
u = linspace(0, 4*pi, m);
v = linspace(0, pi, n);              
                
% Create two matrices U and V containing the u- and v- coordinates of the 
% points in rectangular (u,v)-parameter domain:
[U, V] = meshgrid(u, v);

% Create 3 nxm-matrixes X, Y and Z by applying some
% functions to U and V; 
% X, Y and Z contain the x-, y- and z-coordinates of the points 
% representing the mesh of the surface!
X = U.*sin(U).*cos(V);
Y = U.*cos(U).*cos(V); 
Z = U.*sin(V);
% element-wise operation!!

                              
% Plot the surface mesh defined by the three matrices X, Y and Z
% (plot-command: "surf"):
s = surf(X, Y, Z);

axis equal

%% GRAPHICS PART 7: Modifying plot options for a surface

% viewpoint:  
view([40, 40, 20]);

% the same units in x-, y- and z-direction:

% turn off the grid:
grid off;

% installing lights:
light1 = light('Position', [7 15 20]);
light2 = light('Position', [7 -10 -20]);

% color and lighting properties of the surface s: 
set(s, 'FaceColor', 'interp',...
       'EdgeColor', [0.7 0.7 0.7],...
       'FaceLighting','phong',...
       'BackFaceLighting','reverselit',...
       'SelectionHighlight', 'on',...
       'AmbientStrength', 0.3,...
       'DiffuseStrength', 1.0,...
       'SpecularStrength', 0.8,...
       'SpecularExponent', 30);

axis equal

%% EXERCISE: PLOT THE SURFACE 
%                             s(u, v) = [2*v * sin u, u * cos v, cos(u*v)] 
%                             with parameters u, v in [0,pi] and [-1.2,1.2]

%% EXERCISE: PLOT THE NORTHERN HEMISPHERE 

% parametric representation of a sphere centered in O(0,0,0) with radius r: 
% s(u, v) = [r*cos(u)*cos(v), r*sin(u)*cos(v), r*sin(v)] 


%% EXAMPLE: Plotting a cylinder
% base curve of the cylinder is an ellipse in the xy-plane 
% centered in the origin O(0,0,0);
% generators of the cylinder are parallel to the z-axis

clear all;
clc;

% creating the grid that represents the rectangular (u,v)-parameter domain:
m = 20;
n = 50;
u = linspace(0, 1, m);
v = linspace(0, 2*pi, n);
[U, V] = meshgrid(u,v);


% the half axes lengths of the ellipse:
a = 3;
b = 5;


% the mesh of the cylinder (x-, y-, z-coordinates stored in the 
% matrices X, Y and Z, repectively):
X = cos(V)*a + U*0; 
Y = sin(V)*b + U*0;
Z =      V*0 + U*10; 

                              
% Plot the mesh of the cylinder:
s = surf(X, Y, Z);


% viewpoint:  
view([40, 40, 20]);

% the same units in x-, y- and z-direction:
axis equal;

% installing lights:
light1 = light('Position', [25 -5 -10]);
light2 = light('Position', [25  15 -10]);

% color and lighting properties of the surface s: 
set(s, 'FaceColor', [1.0 0.0 0.0],...
       'EdgeColor', [0.7 0.7 0.7],...
       'FaceLighting','phong',...
       'BackFaceLighting','reverselit',...
       'SelectionHighlight', 'on',...
       'AmbientStrength', 0.3,...
       'DiffuseStrength', 1.0,...
       'SpecularStrength', 0.8,...
       'SpecularExponent', 30);


%% EXERCISE: Modify the cylinder example:
%  1.) Use a parabola in the xy-plane as base curve instead of the ellipse
%  2.) modify the direction of the cylinder's generators
%  3.) generate a cylinder whose base curve is a circle which lies in 
%      the zx-plane and whose generators are parallel to [1, 1, 0]


%% EXAMPLE: Plotting a cone
% base curve of the cone is an ellipse in the xy-plane 
%    centered in the origin O(0,0,0).
% The vertex S of the cone lies on the z-axis

clear all;
clc;

% creating the grid that represents the rectangular (u,v)-parameter domain:
m = 20;
n = 50;
u = linspace(0, 1, m);
v = linspace(0, 2*pi, n);
[U, V] = meshgrid(u,v);


% the half axes lengths of the ellipse:
a = 5;
b = 3;

% Vertex
S = [0;0;16];

% The mesh of the cone (x-, y-, z-coordinates stored in the 
%    matrices X, Y and Z, repectively):
X = (1-U).*cos(V)*a + U*S(1); 
Y = (1-U).*sin(V)*b + U*S(2);
Z =        (1-U).*0 + U*S(3); 
                            
% Plot the mesh of the cone:
cone = surf(X, Y, Z);

% the same units in x-, y- and z-direction:
axis equal;

% viewpoint:  
view([30, 30, 60]);

% installing lights:
light1 = light('Position', [25 -5 -10]);
light2 = light('Position', [25 15 -10]);

% color and lighting properties of the surface s: 
set(cone, 'FaceColor', [0.0 0.0 1.0],...
       'EdgeColor', [1.0 1.0 1.0],...
       'FaceLighting','phong',...
       'BackFaceLighting','reverselit',...
       'SelectionHighlight', 'on',...
       'AmbientStrength', 0.3,...
       'DiffuseStrength', 1.0,...
       'SpecularStrength', 0.5,...
       'SpecularExponent', 3);

%% EXERCISE: Modify the cone example:
%  1.) Use a parabola in the xy-plane as base curve instead of the ellipse
%  2.) modify the position of the cone's vertex
%  3.) generate a cone whose base curve is a circle which lies in 
%      the yz-plane and whose vertex is [10, 0, 0]


%% GRAPHICS PART 8: The commands "hold on" and "hold off"

% If you want to plot more than one object into one graphic window
% you can use the commands "hold on" and "hold off".

% Here is an example (a sphere and a cylinder of revolution):

clear all;
clc;


% the sphere:
R = 6; % the radius of the sphere
c = [-R/2; 0; 0] % the center of the sphere
m = 60;
n = 40;
u = linspace(0, 2*pi, m);
v = linspace(-pi/2, pi/2, n);
[U, V] = meshgrid(u,v);

X = c(1) + R*cos(U).*cos(V); 
Y = c(2) + R*sin(U).*cos(V);
Z = c(3) + R*sin(V); 

sph = surf(X, Y, Z);



% retain the current graphic window:
hold on;



% the cylinder:
r = R+c(1);
n = 30;
v = linspace(-R-1, R+1, n);
[U, V] = meshgrid(u,v);

X = cos(U)*r + V*0; 
Y = sin(U)*r + V*0;
Z =          + V*1; 

cyl = surf(X, Y, Z);




% viewpoint:  
view([40, 40, 20]);

% the same units in x-, y- and z-direction:
axis equal;

% installing lights:
light1 = light('Position', [25 -5 -10]);
light2 = light('Position', [25  15 -10]);

% color and lighting properties of the sphere: 
set(sph, 'FaceColor', [0.4 0.4 1.0],...
         'EdgeColor', [0 0 0],...
         'FaceLighting','phong',...
         'BackFaceLighting','reverselit',...
         'SelectionHighlight', 'on',...
         'AmbientStrength', 0.3,...
         'DiffuseStrength', 1.0,...
         'SpecularStrength', 0.8,...
         'SpecularExponent', 30);

% color and lighting properties of the cylinder surface: 
set(cyl, 'FaceColor', [1.0 0.5 0.0],...
         'EdgeColor', [0 0 0],...
         'FaceLighting','phong',...
         'BackFaceLighting','reverselit',...
         'SelectionHighlight', 'on',...
         'AmbientStrength', 0.3,...
         'DiffuseStrength', 1.0,...
         'SpecularStrength', 0.8,...
         'SpecularExponent', 30);




% reset the hold state to the default behavior 
% (clear the existing graphic window): 
hold off;


%% WRITING MATLAB FUNCTIONS ON YOUR OWN

% A function (also called a 'procedure')in MATLAB has the following structure:

% function result = functionName(inputarg1, inputarg2, ...)
%   MATLAB commands
% end

% The input arguments are inputarg1, inputarg2, ...
% The output argument is "result"
% You can also return more thAn one output:

% function [result1, result2, ...] = functionName(inputarg1, inputarg2, ...)
%   MATLAB commands
% end

% Note that each function has to be saved in a separate m-file (file with
% the extension ".m")
% whose name is identical with the name of the function.
% In case of the above example the name of the m-file is "functionName.m"


%% EXAMPLE: procedure "revolveZ" Matrix for the rotation about z

% Input: rotation angle u
% Output: 3x3-matrix R of the revolution about the z-axis

% Write the procedure with the functionName 'revolveZ' 
% and save it in the working directory so that you can use it if desired.


%% CHECKING THE PROCEDURE "revolveZ":

M = revolveZ(pi/2)
p = [5; 2; 3];
q = M*p


%% SURFACES OF REVOLUTION

% In order to generate meshes of surfaces of revolution
% we implement a procedure called "createRevolveMesh".
% We stick to revolutions about the Z-axis.

% INPUT: polygon P as a 3xn-matrix (the columns of P are the vertices
%        of the polygon);
%        interval [u0, u1] for the rotation angle;
%        m: number of points on the mesh in u-direction
% OUTPUT: Three nxm-matrices X, Y, Z containing the x-, y- and z-coordinates 
%        of the resulting mesh

% function [X, Y, Z] = createRevolveMesh(P, u0, u1, m)
%  n = size(P, 2);
%  u = linspace(u0, u1, m);
%  for j = 1:m
%    R = revolveZ(u(j));
%    Prevolved = R*P;
%    X(:,j) = Prevolved(1,:);
%    Y(:,j) = Prevolved(2,:);
%    Z(:,j) = Prevolved(3,:);
%  end 
% end


%% EXAMPLE: Torus with axis = z-axis; center circle radius R; meridian circle radius r 

% A vector v containing the v-values:
n = 30;
v = linspace(0, 2*pi, n); 

% Create the polygon that represents the meridian circle of the torus:
R = 5;
r = 3;
P = [0*v; 
     R + r*cos(v); 
     r*sin(v)]

% Create the mesh of the torus via the procedure 'createRevolveMesh': 
m = 60;


% [X, Y, Z] = ?????????????

% Plot the torus:
s = surf(X, Y, Z);

% viewpoint:  
view([30, 30, 20]);

% the same units in x-, y- and z-direction:
axis equal;

% installing lights:
light1 = light('Position', [0 0 20]);
light2 = light('Position', [7 30 0]);

%color and lighting properties of the surface s: 
set(s, 'FaceColor', % installing lights:
light1 = light('Position', [0 0 20]);
light2 = light('Position', [7 30 0]);

%color and lighting properties of the surface s: 
set(s, 'FaceColor', [1.0 0.0 0.0],...
    'EdgeColor', [0.0 0.0 0.0],...
       'FaceLighting','phong',...
       'BackFaceLighting','reverselit',...
       'SelectionHighlight', 'on',...
       'AmbientStrength', 0.3,...
       'DiffuseStrength', 1.0,...
       'SpecularStrength', 1.0,...
       'SpecularExponent', 3);
,...
       'EdgeColor', [0.0 0.0 0.0],...
       'FaceLighting','phong',...
       'BackFaceLighting','reverselit',...
       'SelectionHighlight', 'on',...
       'AmbientStrength', 0.3,...
       'DiffuseStrength', 1.0,...
       'SpecularStrength', 1.0,...
       'SpecularExponent', 3);


%% EXAMPLE: A SURFACE OF REVOLUTION

% The line l = p1p2 rotates about the Z-axis
% First we start with a straight line parallel to the Z-axis
% P = [0, 10; -10]; 
% Q = [0, 10; 10];

clear all;
clc;


% The axis g = AB of the surface of revolution:

A = [0; 0; -10]; 
B = [0; 0; 10];
t = linspace(0, 1, 6);

x = (1-t)*A(1) + t*B(1);
y = (1-t)*A(2) + t*B(2);
z = (1-t)*A(3) + t*B(3);

plot3(x, y, z, 'Color',...
         [0, 0.6, 0.4],...
         'LineWidth', 6); 
hold on;


%% The generator l = PQ of the surface of revolution:

P = [0; 10; -10]; 
Q = [0; 10; 10];
t = linspace(0, 1, 6);

x = (1-t)*P(1) + t*Q(1);
y = (1-t)*P(2) + t*Q(2);
z = (1-t)*P(3) + t*Q(3);

plot3(x, y, z, 'Color',...
         [1, 0, 0],...
         'LineWidth', 6);
   
% graphic options: 
view([30, 30, 20]);
axis equal;
grid on
xlim([-15, 5])
ylim([-12, 12])
zlim([-12, 12])

hold on;

%% Create the mesh of the surface of revolution using the procedure 'createRevolveMesh':

m = 60;

G(1,:) = x;
G(2,:) = y;
G(3,:) = z;


% [X, Y, Z] = ????????????????????????????????????

light1 = light('Position', [0 0 20]);
light2 = light('Position', [7 30 0]);

surf(X, Y, Z, 'FaceLighting','phong',...
              'FaceColor', [0.0 0.0 1.0],...
              'EdgeColor', [1.0 1.0 1.0],...
              'BackFaceLighting','reverselit',...
              'AmbientStrength', 0.3,...
              'DiffuseStrength', 1.0,...
              'SpecularStrength', 1.0,...
              'SpecularExponent', 5);
  

hold off;  

%% EXERCISE: MODIFY THE GENERATOR G SUCH THAT IT IS NOT PARALLEL TO THE Z-AXIS.
% What type of surface emerges?

   